# Some design details of the DDCMP Framer

The framer takes advantage of a number of features provided by the Raspberry Pico RP2040 chip:

1. High speed programmable I/O state machine engines
2. Dual ARM core
3. USB support

For details, refer to the [RP2040 datasheet](https://datasheets.raspberrypi.org/rp2040/rp2040-datasheet.pdf "Data sheet").

# Receive processing

Synchronous DDCMP reception consists of a number of stages:

1. Demodulation (integral modem case)
2. Byte framing
3. Packet framing

## Demodulation

In the RS-232 DTE case, demodulation (which includes clock and bit data recovery) is done by the modem.  In the RS-232 DCE case, these steps do not really appear since the clock is generated locally and the bits appear as-is on the receive data pin.

For the integral modem, the framer does the demodulation of the FM modulated signal.  (For details, refer to the DMC11 Synchronous Line Unit Maintenance Manual, EK-DMCLU-TM-002.)   One of the PIO state machines handles clock and data recovery.  The approach is vaguely like the classic technique for UART receive; the state machine runs at 16x the nominal data rate, looking for the edge at the start of the bit cell.  It then waits for 3/4 of the bit time, and samples the input state.  If it is the same as at the start of the bit cell, that is a one bit, otherwise it is a zero bit.  The resulting data bit and a bit strobe signal (PIO IRQ signal) are generated by the demodulator state machine and will be used by the byte framing state machine.

## Byte framing

This consists of two stages: sync search, and data byte processing once in sync.  The input to the byte framing PIO state machine is the received data bit stream and clock.  The clock is an input pin for RS-232 DTE mode, the locally generated clock for RS-232 DCE mode, or the recovered bit clock for integral modem mode.

Initially the byte framing state machine is in sync search mode.  In that mode it shifts bits into a 32 bit register, and after each bit, compares the result against 4 SYN bytes (0x96969696).  Note that ideally it would be best to do a 16-bit compare against 2 SYN bytes, but the hardware does not support that and given that other DDCMP devices normally send around 8 SYN bytes before frames, requiring 4 for synchronization is acceptable.  When a match is seen, we have byte sync and the sync search mode is exited.  At this point the SYN LED is turned on.

When synchronized, the byte framing state machine continues to shift in bits to the input register, and every 32 bits pushes the result to the receive FIFO.  That FIFO is processed by the ARM (core 1), which will see properly framed bytes 4 at a time.

To go back to sync search state, for example to recover from a header CRC error or invalid start of header byte, the ARM core will force the byte framing state machine back to its starting address, which puts it back in sync search state.

## Packet framing

Packet framing is done in the ARM CPU since it is too complex for the PIO state machines.  Because of the real time requirements, core 1 is dedicated to this task; it runs in a tight loop receiving bytes 4 at a time from the byte framing PIO state machine through its receive FIFO.

The packet framer basically implements the DDCMP packet format recognition state machine seen in many other implementations of DDCMP.  It skips leading SYN bytes, then expects a valid start of frame byte (ENQ, SOH, or DLE) followed by 5 more header bytes and a correct 2 byte CRC-16 header CRC.  If the first non-SYN byte is not valid, the packet framer resets the byte framer state machine to sync search mode and goes back to looking for a valid frame start.

If the first byte is a valid start of frame, the framer examines the next entry in the receive buffer ring.  If it is in use, we have a no-buffers condition, which is counted as an error and sync search mode is entered to look for the next frame.  Otherwise, the framer begins to store arriving bytes into that buffer and accumulates the (header) CRC.  After 8 bytes, it verifies the CRC; if it is non-zero, the frame is completed with header CRC error status and sync search is entered.  

If the header CRC is good and the frame is a control frame (ENQ first byte), the buffer is completed as a good frame, and the framer goes back to look for the next frame.  Note that we do not do sync search in this case since the link is currently synchronized.  Other frame types are data; if so, the length field is extracted from the received header.  If it is invalid (zero or greater than 1488), this is counted as a length error and sync search is started.  Otherwise, the framer accumulates the next (length + 2) bytes, which are the frame payload and data CRC.

Once the data and data CRC have been received and buffered, the framer checks for zero CRC.  If so, the frame is marked as complete and good; otherwise, it is marked as commplete with data CRC error.  In either case, the framer goes back to look for another frame.  Unlike header CRC errors, data CRC errors do not trigger sync search.

# Transmit processing

Similar to receive processing, transmit processing for synchronous DDCMP consists of several parts:

1. Frame construction
2. Bit stream generation
3. Modulation

## Frame construction

The connected host supplies complete DDCMP frames to the framer except that the CRC fields are omitted.  The host request handler (in ARM CPU 0) copies the frame to be transmitted into the next transmit ring buffer, if free.  As part of the copy, the CRC is calculated and inserted after the header and, if applicable, the data.  After the end of frame a DEL byte (0xff) is inserted, this is as specified in the DDCMP spec to strengthen the CRC in case a bit is lost or inserted.

Frames are sent to the bit handling state machines using DMA, and to avoid underrun the state machine FIFO is set to 32 bits wide.  To handle this, the completed frame is padded with SYN bytes to the next multiple of 4.  Also, the transmit ring buffer contains 8 SYN bytes before the frame data area, which will be the sync pattern sent before each frame.  Currently there is no support for sending short sync sequences when permitted, that would only be an optimization and for many cases isn't all that interesting.

Once the complete frame has been built, the buffer is marked as filled.  If DMA is not currently in progress, DMA of the new buffer is started by submitting its start address (address of the leading SYN sequence) and length to the DMA engine.  If DMA is in progress, this new buffer will be handled by the DMA completion interrupt handler when the DMA for the preceding buffer finishes.

## Bit stream generation and modulation

For RS-232 mode, the output bit stream is simply the sequence of bits (LSB first) from the transmitted packet.  The transmit handler for these modes picks up words from the output FIFO and shifts them a bit at a time to the transmit data pin.  For DTE mode, the shifting happens on the rising edge of the transmit clock input.  For DCE mode, the state machine runs at 4x the required data rate and it shifts output bits and generates the clock signal in a four-instruction loop.

For integral modem mode, the output signal is an FM modulated signal representing the bit stream, with an edge at the beginning of each bit cell and a second edge in the middle if the transmitted bit is a zero.  The PIO state machine program for this mode fetches 32-bit words from the FIFO, then shifts out one bit at a time and generates the correct waveform based on whether the bit is one or zero.  It runs at 4x the required data rate.  Note that for the integral modem case there is no connection between receive and transmit clocks, though the nominal values are expected to match.

# Host interface handling

The host interface uses the TinyUSB open source library, in device mode configured as an Ethernet device.  Some of the bits are adapted from the TinyUSB web server example, but note that the DDCMP Framer uses raw Ethernet, not IP.

The main loop, running in ARM CPU 0, polls the USB for outgoing Ethernet frames and the received packet ring (from CPU 1) for incoming DDCMP frames to be sent to the host.

## Outbound frame processing (host to framer)

The framer checks the Ethernet protocol type field for the value 60-06 (the DEC reserved value for "customer use").  Frames with other protocol types are ignored.  Some will appear because operating services like DHCP or other configuration mechanisms may send IP frames on any interface that shows up.

If a framer type frame is seen, the first byte of the data is examined to see if it is a command or a frame to be transmitted.  Transmit frames are recognized by the fact that they start with one of the DDCMP frame start values EQN (005), SOH (201) or DLE (220).  Command use a DC1 (021) byte instead.  Any other first byte is an error.

Data frames are copied into a transmit buffer with CRC generated during the copy, then transmitted as described above.

Invalid requests including invalid transmits (such as bad frame lengths) are reported by the framer generating a status message to the host, in which the last_cmd_sts field is set to a non-zero value indicating the error.  Apart from that reporting, the request that encountered the error is ignored.

Commands have a command code in the second byte.  Defined commands are status request, off, on, and raw transmit.  Raw transmit is a test tool for diagnostics, it is not expected to be used in normal operation.  On and raw transmit requests have data following the command code, see the API document for details.

All commands except for a valid raw transmit generate a status reply.  Valid raw transmits are handled (the data is transmitted exactly as supplied, without any leading SYN, CRC handling, or trailing bytes added) with no status reply.

### "On" command

The command to start the framer includes additional data specifying the operating mode and data rate.  Refer to the API spec for details.

Command processing sets all the Pico pins to the proper operating setting, loads the appropriate programs into the PIO state machines, configures them, and starts them.  It also starts CPU 1 if that has not already been done (it is done only once per power up since CPU 1 can't be stopped after having been started).

Two of the PIO state machines control the receive and transmit activity LEDs, providing "pulse stretching" so the light flashes are bright enough to be visible if traffic is sporadic.  They flash once when started, so the execution of the "On" command will light the "active" LED (on the Pico board) and flash the RX and TX LEDs once.  The SYN LED will be off until a valid signal is received and byte sync is established.

## Inbound frame processing (framer to host)

In the main loop the framer looks for things to send to the host.  There are two cases: status, and received data.  Status takes precedence.

At any time when status needs to be reported, the `send_status` flag is set.  If it seen set in the main loop, the status buffer is sent to the host and the flag cleared.

Otherwise, if the next buffer in the receive ring is not free, it is sent to the host and marked free.

All packets from framer to host have an Ethernet header with DA AA-00-03-04-05-06, SA AA-00-03-04-05-07, and protocol type 60-06.  The first two bytes of data are the receive status, which is 0 for good frames and non-zero for various error cases such as header CRC error.  (Refer to the API spec for details.)  Status frames always have 0 receive status.

# BIST

Built-in self test is intended mostly as a simple test to verify a newly built framer is working correctly.  In BIST mode, the framer continuously transmits 500 byte frames (MOP mode frames) containing an incrementing sequence number followed by a mixed data pattern.  Any received frames are counted but otherwise ignored.  Transmit requests from the host are silently ignored, but status requests and stop command are honored.  Every 1000 transmits, a status message is generated.

There are two ways to invoke BIST:

## Power up BIST

If GPIO pin 2 is grounded at framer power up (for example, by installing a jumper on 2-pin header TEST), this forces BIST, integral modem, internal loopback.  The USB interface is still active.

## BIST mode in Framer On commands

The host can request BIST mode as part of an "On" command.  This allows BIST mode to be run (i.e., the traffic generator and receive packet ignore functions) with other operating modes such as RS-232 and external loopback, or no loopback at all.  Several of the tests in the framer test suite in PyDECnet use this option.

